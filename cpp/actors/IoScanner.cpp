//
// Created by Benjamin van Seggelen
//
#include <string>
#include "utils/Logger.h"

#include "DiscoveryManager.h"
#include "ConnectionManager.h"
#include "SessionInfo.h"
#include "cip/connectionManager/NetworkConnectionParams.h"

using eipScanner::ConnectionManager;
using eipScanner::DiscoveryManager;
using eipScanner::IdentityItem;
using eipScanner::SessionInfo;
using eipScanner::cip::connectionManager::ConnectionParameters;
using eipScanner::cip::connectionManager::NetworkConnectionParams;
using eipScanner::utils::Logger;
using eipScanner::utils::LogLevel;

ConnectionParameters GenerateConnectionParams()
{
  ConnectionParameters parameters;
  parameters.connectionPath = {0x20, 0x04, 0x24, 151, 0x2C, 150, 0x2C, 100}; // config Assm151, output Assm150, intput Assm100
  parameters.o2tRealTimeFormat = true;
  parameters.originatorVendorId = 342;
  parameters.t2oNetworkConnectionParams |= NetworkConnectionParams::P2P;
  parameters.t2oNetworkConnectionParams |= NetworkConnectionParams::SCHEDULED_PRIORITY;
  parameters.t2oNetworkConnectionParams |= 32; // size of Assm100 =32
  parameters.o2tNetworkConnectionParams |= NetworkConnectionParams::P2P;
  parameters.o2tNetworkConnectionParams |= NetworkConnectionParams::SCHEDULED_PRIORITY;
  parameters.o2tNetworkConnectionParams |= 32; // size of Assm150 = 32

  parameters.originatorSerialNumber = 0x12345;
  parameters.o2tRPI = 1000000;
  parameters.t2oRPI = 1000000;
  parameters.transportTypeTrigger |= NetworkConnectionParams::CLASS1;

  return parameters;
}

std::vector<uint8_t> GeneratePacket(uint16_t sequenceNumber)
{
  std::vector<uint8_t> packet;
  std::string baseString = "Packet: ";
  std::string sequenceString = std::to_string(sequenceNumber);

  for (char character : baseString)
  {
    packet.push_back(character);
  }

  for (char character : sequenceString)
  {
    packet.push_back(character);
  }

  while (packet.size() < 32)
  {
    packet.push_back(0);
  }

  return packet;
}

int main()
{
  Logger::setLogLevel(LogLevel::DEBUG);
  IdentityItem::Vec devices;
  while (devices.size() == 0)
  {
    DiscoveryManager discoveryManager("172.28.255.255", 0xAF12, std::chrono::seconds(5));
    devices = discoveryManager.discover();
  }

  if (devices.size() > 1)
  {
    Logger(LogLevel::ERROR) << "Expected 1 device, not more or less.";
    return EXIT_FAILURE;
  }

  auto si = std::make_shared<SessionInfo>(devices.at(0).socketAddress.getHost(), 0xAF12);

  ConnectionManager connectionManager;
  ConnectionParameters parameters = GenerateConnectionParams();

  // TODO: set up implicit messaging
  auto io = connectionManager.forwardOpen(si, parameters);
  if (auto ptr = io.lock())
  {
    ptr->setDataToSend(GeneratePacket(0));

    ptr->setReceiveDataListener([&ptr](auto realTimeHeader, auto sequence, auto data)
                                {
      std::ostringstream ss;
      ss << "secNum=" << sequence << " data=";
      for (auto &byte : data) {
        ss << "[" << std::hex << (int) byte << "]";
      }
      ptr->setDataToSend(GeneratePacket(sequence));

      Logger(LogLevel::INFO) << "Received: " << ss.str(); });

    ptr->setCloseListener([]()
                          { Logger(LogLevel::INFO) << "Closed"; });
  }

  while (connectionManager.hasOpenConnections())
  {
    connectionManager.handleConnections(std::chrono::milliseconds(100));
  }

  connectionManager.forwardClose(si, io);

  return EXIT_SUCCESS;
}